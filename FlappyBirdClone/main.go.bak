// Package declaration: defines the package for this file.
package main

// Import statements: bring in required standard and external libraries.
import (
    "fmt"                     // For formatting strings (e.g., score text).
    "log"                     // For logging errors (e.g., image loading failures).
    "math/rand"               // For generating random pipe gap heights.
    "time"                    // For seeding the random number generator.
    "github.com/hajimehoshi/ebiten/v2" // Ebiten library for 2D game functionality (graphics, input, game loop).
    "github.com/hajimehoshi/ebiten/v2/ebitenutil" // Ebiten utilities for drawing shapes and debug text.
)

// Game struct: holds the game state and assets.
type Game struct {
    birdY         float64       // Bird's vertical position (Y-coordinate, pixels).
    gravity       float64       // Gravity force applied per frame (pixels).
    flapForce     float64       // Upward force when flapping (negative for upward movement).
    pipes         []Pipe        // Slice of Pipe structs for obstacles.
    frame         int           // Frame counter for timing (e.g., pipe spawning).
    score         int           // Player’s score (increments when passing pipes).
    state         string        // Game state: "playing" or "gameOver".
    groundX       float64       // Ground’s horizontal offset for scrolling (pixels).
    birdImg       *ebiten.Image // Image for the bird (e.g., bird-0.png).
    pipeImg       *ebiten.Image // Image for pipes (e.g., pipe-green.png).
    groundImg     *ebiten.Image // Image for ground (e.g., base.png).
    backgroundImg *ebiten.Image // Image for background (e.g., background-day.png).
}

// Pipe struct: represents a single pipe obstacle (top and bottom pair).
type Pipe struct {
    x      float64 // Pipe’s horizontal position (X-coordinate, pixels).
    gapY   float64 // Vertical center of the gap between top and bottom pipes (pixels).
    scored bool    // Tracks if the pipe has been scored (prevents double-scoring).
}

// NewGame: initializes a new game instance with default values and loaded images.
func NewGame() *Game {
    // Seed the random number generator with the current time for varied pipe gaps.
    rand.Seed(time.Now().UnixNano())

    // Load bird image from bird.png.
    birdImg, _, err := ebitenutil.NewImageFromFile("bird.png")
    // If loading fails (e.g., file missing), log the error and exit.
    if err != nil {
        log.Fatal(err)
    }
    // Load pipe image from pipe.png.
    pipeImg, _, err := ebitenutil.NewImageFromFile("pipe.png")
    if err != nil {
        log.Fatal(err)
    }
    // Load ground image from ground.png.
    groundImg, _, err := ebitenutil.NewImageFromFile("ground.png")
    if err != nil {
        log.Fatal(err)
    }
    // Load background image from background.png.
    backgroundImg, _, err := ebitenutil.NewImageFromFile("background.png")
    if err != nil {
        log.Fatal(err)
    }

    // Return a pointer to a new Game struct with initialized values.
    return &Game{
        birdY:         200.0,         // Start bird in the middle of the 400px screen.
        gravity:       0.5,           // Gravity pulls bird down 0.5 pixels per frame.
        flapForce:     -10.0,         // Flapping moves bird up 10 pixels.
        pipes:         []Pipe{},      // Initialize empty slice for pipes.
        frame:         0,             // Start frame counter at 0.
        score:         0,             // Start score at 0.
        state:         "playing",     // Start in playing state.
        groundX:       0.0,           // Ground starts at X=0 (no offset).
        birdImg:       birdImg,       // Assign loaded bird image.
        pipeImg:       pipeImg,       // Assign loaded pipe image.
        groundImg:     groundImg,     // Assign loaded ground image.
        backgroundImg: backgroundImg, // Assign loaded background image.
    }
}

// Update: runs each frame to update game logic (60 FPS by default in Ebiten).
func (g *Game) Update() error {
    // If in game-over state, check for restart input.
    if g.state == "gameOver" {
        // If R key is pressed, reset the game by assigning a new Game instance.
        if ebiten.IsKeyPressed(ebiten.KeyR) {
            *g = *NewGame()
        }
        // No further updates in game-over state; return nil (no error).
        return nil
    }

    // Increment frame counter for timing (e.g., pipe spawning).
    g.frame++

    // Handle bird movement: flap on spacebar press.
    if ebiten.IsKeyPressed(ebiten.KeySpace) {
        // Apply upward flap force (negative to move up).
        g.birdY += g.flapForce
    }
    // Apply gravity to move bird down each frame.
    g.birdY += g.gravity

    // Spawn a new pipe every 90 frames (roughly every 1.5 seconds at 60 FPS).
    if g.frame%90 == 0 {
        // Random gap center between 150 and 250 pixels (100px range).
        gapY := 150.0 + rand.Float64()*100.0
        // Add new pipe at X=400 (right edge) with scored=false.
        g.pipes = append(g.pipes, Pipe{x: 400.0, gapY: gapY, scored: false})
    }

    // Move pipes left and check for scoring.
    for i := range g.pipes {
        // Move each pipe left by 2 pixels per frame.
        g.pipes[i].x -= 2.0
        // Score when bird passes pipe (bird at X=100, pipe crosses X=90).
        if g.pipes[i].x < 90.0 && !g.pipes[i].scored {
            // Increment score and mark pipe as scored.
            g.score++
            g.pipes[i].scored = true
        }
    }

    // Remove off-screen pipes to optimize memory.
    newPipes := []Pipe{}
    for _, pipe := range g.pipes {
        // Keep pipes with X >= -50 (slightly off-screen to avoid visual gaps).
        if pipe.x >= -50.0 {
            newPipes = append(newPipes, pipe)
        }
    }
    // Update pipes slice with only on-screen pipes.
    g.pipes = newPipes

    // Check collisions with pipes.
    for _, pipe := range g.pipes {
        // Check if bird (X=100) is within pipe’s collision zone (X=90 to 110).
        if pipe.x <= 110.0 && pipe.x >= 90.0 {
            // Gap is 100px tall, centered at gapY.
            gapTop := pipe.gapY - 50.0    // Top edge of gap.
            gapBottom := pipe.gapY + 50.0 // Bottom edge of gap.
            // If bird is above gapTop or below gapBottom, collide.
            if g.birdY < gapTop || g.birdY > gapBottom {
                // Switch to game-over state and stop updating.
                g.state = "gameOver"
                return nil
            }
        }
    }

    // Check collisions with ground and ceiling.
    if g.birdY < 0 || g.birdY > 360 {
        // Bird hits ceiling (Y=0) or ground (Y=360, ground’s top edge).
        g.state = "gameOver"
        return nil
    }

    // No errors; return nil to continue the game loop.
    return nil
}

// Draw: renders the game visuals each frame.
func (g *Game) Draw(screen *ebiten.Image) {
    // If in game-over state, show game-over screen.
    if g.state == "gameOver" {
        // Display “Game Over”, score, and restart instructions using DebugPrint.
        ebitenutil.DebugPrint(screen, fmt.Sprintf("Game Over\nScore: %d\nPress R to Restart", g.score))
        // Exit Draw to avoid rendering gameplay visuals.
        return
    }

    // Draw background (scaled to 400x400).
    backgroundOpts := &ebiten.DrawImageOptions{}
    // Scale 288x512 background to 400x400 (width: 400/288 ≈ 1.39, height: 400/512 ≈ 0.78).
    backgroundOpts.GeoM.Scale(400.0/288.0, 400.0/512.0)
    // Draw background image at (0,0) to fill the screen.
    screen.DrawImage(g.backgroundImg, backgroundOpts)

    // Draw ground (scrolling).
    groundOpts := &ebiten.DrawImageOptions{}
    // Position first ground segment at current groundX, Y=360 (40px tall).
    groundOpts.GeoM.Translate(g.groundX, 360.0)
    screen.DrawImage(g.groundImg, groundOpts)
    // Reset transformation matrix to avoid affecting the next draw.
    groundOpts.GeoM.Reset()
    // Position second ground segment at groundX+400 for seamless scrolling.
    groundOpts.GeoM.Translate(g.groundX+400.0, 360.0)
    screen.DrawImage(g.groundImg, groundOpts)

    // Draw bird.
    birdOpts := &ebiten.DrawImageOptions{}
    // Position bird at X=100, Y=birdY (dynamic based on flapping/gravity).
    birdOpts.GeoM.Translate(100.0, g.birdY)
    screen.DrawImage(g.birdImg, birdOpts)

    // Draw pipes.
    for _, pipe := range g.pipes {
        // Calculate gap boundaries (100px tall, centered at gapY).
        gapTop := pipe.gapY - 50.0
        gapBottom := pipe.gapY + 50.0

        // Top pipe (rotated 180 degrees).
        topOpts := &ebiten.DrawImageOptions{}
        // Rotate 180 degrees (π radians) to flip pipe upside-down.
        topOpts.GeoM.Rotate(3.14159)
        // Position at pipe.x+52 (pipe width), gapTop (adjusted for rotation).
        topOpts.GeoM.Translate(pipe.x+52.0, gapTop)
        screen.DrawImage(g.pipeImg, topOpts)

        // Bottom pipe (no rotation).
        bottomOpts := &ebiten.DrawImageOptions{}
        // Position at pipe.x, gapBottom (bottom pipe’s top edge).
        bottomOpts.GeoM.Translate(pipe.x, gapBottom)
        screen.DrawImage(g.pipeImg, bottomOpts)
    }

    // Draw live score in top-left corner.
    ebitenutil.DebugPrint(screen, fmt.Sprintf("Score: %d", g.score))
}

// Layout: sets the logical screen size.
func (g *Game) Layout(outsideWidth, outsideHeight int) (int, int) {
    // Return 400x400 as the fixed screen size, ignoring window size.
    return 400, 400
}

// main: entry point of the program.
func main() {
    // Create a new game instance.
    game := NewGame()
    // Set the window size to 400x400 pixels.
    ebiten.SetWindowSize(400, 400)
    // Set the window title.
    ebiten.SetWindowTitle("Flappy Bird Clone")
    // Run the game loop; log any errors and exit if RunGame fails.
    if err := ebiten.RunGame(game); err != nil {
        log.Fatal(err)
    }
}
